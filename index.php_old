<!DOCTYPE html>

<?php
$jsonFile = 'data.json';

// Handle AJAX requests for saving FIRST
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $input = file_get_contents('php://input');
    $postData = json_decode($input, true);

    if (!$postData) {
        $postData = $_POST;
    }

    header('Content-Type: application/json');

    if (isset($postData['action']) && $postData['action'] === 'save') {
        try {
            // Validate data structure
            if (!isset($postData['data'])) {
                echo json_encode(['success' => false, 'message' => 'No data provided']);
                exit;
            }

            $dataToSave = $postData['data'];

            // Save new data
            $jsonData = json_encode($dataToSave, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);

            if ($jsonData === false) {
                echo json_encode(['success' => false, 'message' => 'Failed to encode JSON: ' . json_last_error_msg()]);
                exit;
            }

            // Atomic write operation
            $tempFile = $jsonFile . '.tmp';
            if (file_put_contents($tempFile, $jsonData, LOCK_EX) === false) {
                echo json_encode(['success' => false, 'message' => 'Failed to write temporary file']);
                exit;
            }

            if (!rename($tempFile, $jsonFile)) {
                unlink($tempFile); // Clean up temp file
                echo json_encode(['success' => false, 'message' => 'Failed to move temporary file']);
                exit;
            }

            // Success response
            echo json_encode([
                'success' => true,
                'message' => 'Data saved successfully',
                'timestamp' => date('Y-m-d H:i:s'),
                'fileSize' => filesize($jsonFile)
            ]);
        } catch (Exception $e) {
            error_log("Save error: " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => 'Server error: ' . $e->getMessage()]);
        }

        exit;
    }
}

// Check if file exists and is readable
if (!file_exists($jsonFile)) {
    die("Error: data.json file not found in " . __DIR__);
}

if (!is_readable($jsonFile)) {
    die("Error: data.json file is not readable. Check file permissions.");
}

// Get file contents
$jsonContent = file_get_contents($jsonFile);
if ($jsonContent === false) {
    die("Error: Could not read data.json file");
}

// Check if file is empty
if (empty(trim($jsonContent))) {
    die("Error: data.json file is empty");
}

// First, try to decode as-is
$data = json_decode($jsonContent, true);

// If JSON is invalid, create sample data
if ($data === null) {
    $sampleData = [
        'book_id' => 1150,
        'title' => 'Sample Book',
        'chapters' => [
            [
                'id' => 1,
                'title' => 'Sample Chapter',
                'questions' => [
                    [
                        'id' => 1,
                        'title' => 'Sample Question',
                        'answers' => [
                            [
                                'id' => 1,
                                'user_id' => 1,
                                'author_first_name' => 'User',
                                'author_last_name' => '',
                                'answer' => json_encode([
                                    'time' => time() * 1000,
                                    'blocks' => [
                                        [
                                            'id' => 'block1',
                                            'type' => 'paragraph',
                                            'data' => [
                                                'text' => 'Sample content here...'
                                            ]
                                        ]
                                    ]
                                ])
                            ]
                        ]
                    ]
                ]
            ]
        ]
    ];

    file_put_contents($jsonFile, json_encode($sampleData, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE));
    $data = $sampleData;
}
?>

<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Docs Style - Book Editor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@300;400;500;600&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Google Sans', 'Roboto', sans-serif;
            background: #f9fbfd;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Google Docs Header */
        .header {
            background: #fff;
            border-bottom: 1px solid #e8eaed;
            height: 64px;
            display: flex;
            align-items: center;
            padding: 0 24px;
            position: relative;
            z-index: 1000;
            box-shadow: 0 1px 3px rgba(60, 64, 67, .1);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .docs-icon {
            width: 40px;
            height: 40px;
            background: #4285f4;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 500;
            font-size: 18px;
        }

        .document-name {
            font-size: 18px;
            color: #3c4043;
            font-weight: 400;
            border: none;
            background: transparent;
            outline: none;
            padding: 6px 8px;
            border-radius: 4px;
            min-width: 200px;
        }

        .document-name:hover {
            background: #f8f9fa;
        }

        .header-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .status-indicator {
            font-size: 13px;
            color: #5f6368;
            padding: 4px 8px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dadce0;
        }

        .status-saving {
            color: #1a73e8;
            background: #e8f0fe;
        }

        .status-saved {
            color: #137333;
            background: #e6f4ea;
        }

        .status-error {
            color: #d93025;
            background: #fce8e6;
        }

        .share-btn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
        }

        .share-btn:hover {
            background: #1557b8;
        }

        /* Google Docs Toolbar */
        .toolbar-container {
            background: white;
            border-bottom: 1px solid #e8eaed;
            position: relative;
        }

        .toolbar {
            display: flex;
            align-items: center;
            padding: 8px 24px;
            gap: 2px;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .toolbar::-webkit-scrollbar {
            display: none;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0 6px;
            border-right: 1px solid #e8eaed;
            margin-right: 8px;
        }

        .toolbar-section:last-child {
            border-right: none;
            margin-right: 0;
        }

        .toolbar-btn {
            min-width: 28px;
            height: 28px;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #3c4043;
            position: relative;
            transition: background 0.2s;
        }

        .toolbar-btn:hover {
            background: #f8f9fa;
        }

        .toolbar-btn.active {
            background: #e8f0fe;
            color: #1a73e8;
        }

        .toolbar-select {
            border: none;
            background: transparent;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 14px;
            color: #3c4043;
            cursor: pointer;
            min-width: 80px;
        }

        .toolbar-select:hover {
            background: #f8f9fa;
        }

        .font-family-select {
            min-width: 140px;
        }

        .font-size-select {
            min-width: 60px;
        }

        /* Main Layout */
        .main-layout {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: white;
            border-right: 1px solid #e8eaed;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e8eaed;
            background: #f8f9fa;
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: 500;
            color: #3c4043;
            margin-bottom: 12px;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #dadce0;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            outline: none;
        }

        .search-input:focus {
            border-color: #1a73e8;
            box-shadow: 0 0 0 2px rgba(26, 115, 232, .2);
        }

        .questions-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .question-item {
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 4px;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .question-item:hover {
            background: #f8f9fa;
        }

        .question-item.active {
            background: #e8f0fe;
            border-color: #1a73e8;
        }

        .question-chapter {
            font-size: 12px;
            color: #5f6368;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .question-title {
            font-size: 14px;
            color: #3c4043;
            line-height: 1.4;
        }

        /* Editor Area */
        .editor-area {
            flex: 1;
            display: flex;
            justify-content: center;
            background: #f9fbfd;
            overflow-y: auto;
            padding: 24px;
        }

        .document-wrapper {
            width: 100%;
            max-width: 816px;
        }

        /* Document Pages with Auto Page Break */
        .document-page {
            background: white;
            width: 816px;
            min-height: 1056px;
            max-height: 1056px;
            margin: 0 auto 24px;
            padding: 96px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, .1);
            border-radius: 2px;
            position: relative;
            overflow: hidden;
            page-break-after: always;
        }

        .document-page:last-child {
            page-break-after: avoid;
        }

        .page-header {
            margin-bottom: 24px;
            border-bottom: 1px solid #e8eaed;
            padding-bottom: 16px;
        }

        .question-title-input {
            width: 100%;
            font-size: 24px;
            font-weight: 400;
            color: #3c4043;
            border: none;
            outline: none;
            background: transparent;
            font-family: 'Google Sans', sans-serif;
            padding: 8px 0;
        }

        .question-title-input::placeholder {
            color: #9aa0a6;
        }

        .page-content {
            min-height: 600px;
            max-height: 864px;
            font-family: 'Times New Roman', serif;
            font-size: 12pt;
            line-height: 1.15;
            color: #000;
            outline: none;
            word-wrap: break-word;
            overflow: visible;
        }

        .page-content:empty::before {
            content: 'Start writing your answer here...';
            color: #9aa0a6;
            font-style: italic;
        }

        .page-number {
            position: absolute;
            bottom: 24px;
            right: 32px;
            font-size: 10px;
            color: #5f6368;
        }

        /* Content Formatting */
        .page-content h1,
        .page-content h2,
        .page-content h3,
        .page-content h4,
        .page-content h5,
        .page-content h6 {
            margin: 16px 0 8px 0;
            font-weight: bold;
        }

        .page-content h1 {
            font-size: 20pt;
        }

        .page-content h2 {
            font-size: 16pt;
        }

        .page-content h3 {
            font-size: 14pt;
        }

        .page-content h4 {
            font-size: 12pt;
        }

        .page-content h5 {
            font-size: 11pt;
        }

        .page-content h6 {
            font-size: 10pt;
        }

        .page-content p {
            margin: 0 0 12px 0;
        }

        .page-content ul,
        .page-content ol {
            margin: 12px 0;
            padding-left: 36px;
        }

        .page-content li {
            margin-bottom: 6px;
        }

        .page-content blockquote {
            margin: 12px 0;
            padding-left: 24px;
            border-left: 4px solid #dadce0;
            color: #5f6368;
            font-style: italic;
        }

        .page-content img {
            max-width: 100%;
            height: auto;
            margin: 12px 0;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, .1);
        }

        .page-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 12px 0;
        }

        .page-content th,
        .page-content td {
            border: 1px solid #dadce0;
            padding: 8px 12px;
            text-align: left;
        }

        .page-content th {
            background: #f8f9fa;
            font-weight: 500;
        }

        /* Loading States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #5f6368;
            font-style: italic;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #1a73e8;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 12px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
                margin: 0;
                padding: 0;
            }

            .header,
            .toolbar-container,
            .sidebar {
                display: none !important;
            }

            .main-layout {
                display: block;
            }

            .editor-area {
                padding: 0;
                background: white;
            }

            .document-page {
                margin: 0;
                box-shadow: none;
                border-radius: 0;
                page-break-after: always;
            }

            .document-page:last-child {
                page-break-after: avoid;
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
    </style>
</head>

<body>
    <!-- Google Docs Header -->
    <div class="header">
        <div class="header-left">
            <div class="docs-icon">📖</div>
            <input type="text" class="document-name" id="documentName" value="Book Editor" readonly>
        </div>
        <div class="header-right">
            <div class="status-indicator status-saved" id="statusIndicator">
                <span id="statusText">All changes saved</span>
            </div>
            <button class="share-btn" onclick="exportToPDF()" id="exportPdfBtn">📄 Export PDF</button>
            <button class="share-btn" onclick="saveAllChanges()">💾 Save All</button>
        </div>
    </div>

    <!-- Google Docs Toolbar -->
    <div class="toolbar-container">
        <div class="toolbar">
            <!-- Undo/Redo -->
            <div class="toolbar-section">
                <button class="toolbar-btn" onclick="execCommand('undo')" title="Undo (Ctrl+Z)">↶</button>
                <button class="toolbar-btn" onclick="execCommand('redo')" title="Redo (Ctrl+Y)">↷</button>
            </div>

            <!-- Print -->
            <div class="toolbar-section">
                <button class="toolbar-btn" onclick="printDocument()" title="Print (Ctrl+P)">🖨️</button>
            </div>

            <!-- Font Family -->
            <div class="toolbar-section">
                <select class="toolbar-select font-family-select" onchange="changeFontFamily(this.value)">
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Arial">Arial</option>
                    <option value="Calibri">Calibri</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Helvetica">Helvetica</option>
                </select>
            </div>

            <!-- Font Size -->
            <div class="toolbar-section">
                <select class="toolbar-select font-size-select" onchange="changeFontSize(this.value)">
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                    <option value="11">11</option>
                    <option value="12" selected>12</option>
                    <option value="14">14</option>
                    <option value="16">16</option>
                    <option value="18">18</option>
                    <option value="20">20</option>
                    <option value="24">24</option>
                </select>
            </div>

            <!-- Text Formatting -->
            <div class="toolbar-section">
                <button class="toolbar-btn" id="boldBtn" onclick="toggleFormat('bold')" title="Bold (Ctrl+B)"><strong>B</strong></button>
                <button class="toolbar-btn" id="italicBtn" onclick="toggleFormat('italic')" title="Italic (Ctrl+I)"><em>I</em></button>
                <button class="toolbar-btn" id="underlineBtn" onclick="toggleFormat('underline')" title="Underline (Ctrl+U)"><u>U</u></button>
            </div>

            <!-- Alignment -->
            <div class="toolbar-section">
                <button class="toolbar-btn" onclick="alignText('left')" title="Align left">⬅️</button>
                <button class="toolbar-btn" onclick="alignText('center')" title="Center">⬆️</button>
                <button class="toolbar-btn" onclick="alignText('right')" title="Align right">➡️</button>
                <button class="toolbar-btn" onclick="alignText('justify')" title="Justify">⬌</button>
            </div>

            <!-- Lists -->
            <div class="toolbar-section">
                <button class="toolbar-btn" onclick="insertList('ul')" title="Bullet list">•</button>
                <button class="toolbar-btn" onclick="insertList('ol')" title="Numbered list">1.</button>
            </div>

            <!-- Insert -->
            <div class="toolbar-section">
                <button class="toolbar-btn" onclick="insertLink()" title="Insert link">🔗</button>
                <button class="toolbar-btn" onclick="insertImage()" title="Insert image">🖼️</button>
            </div>

            <!-- Styles -->
            <div class="toolbar-section">
                <select class="toolbar-select" onchange="applyStyle(this.value)">
                    <option value="p">Normal text</option>
                    <option value="h1">Heading 1</option>
                    <option value="h2">Heading 2</option>
                    <option value="h3">Heading 3</option>
                    <option value="h4">Heading 4</option>
                    <option value="h5">Heading 5</option>
                    <option value="h6">Heading 6</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="main-layout">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Document Outline</div>
                <input type="text" class="search-input" id="searchInput" placeholder="Search questions...">
            </div>
            <div class="questions-container" id="questionsContainer">
                <div class="loading">
                    <div class="spinner"></div>
                    Loading questions...
                </div>
            </div>
        </div>

        <!-- Editor Area -->
        <div class="editor-area">
            <div class="document-wrapper" id="documentWrapper">
                <!-- Pages will be dynamically created here -->
                <div class="document-page" id="page-1">
                    <div class="page-header">
                        <input type="text" class="question-title-input" id="questionTitle" placeholder="Enter question title...">
                    </div>
                    <div class="page-content" id="pageContent-1" contenteditable="true">
                        <p>Select a question from the sidebar to start editing...</p>
                    </div>
                    <div class="page-number">Page 1</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global Variables
        let data = <?= json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES) ?>;
        let currentChapter = -1;
        let currentQuestion = -1;
        let autoSaveTimer;
        let isLoading = false;
        let currentPageCount = 1;
        let pageBreakTimer;
        let autoSaveCount = 0;
        let lastServerSave = Date.now();

        // Page height monitoring - EXACTLY like Google Docs
        const MAX_PAGE_HEIGHT = 800; // Exact page content height

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        function initializeApp() {
            console.log('🚀 Initializing application...');

            if (!data || !data.chapters) {
                console.error('❌ No data loaded');
                updateStatus('Error: No data loaded', 'status-error');
                return;
            }

            loadSidebar();
            setupEventListeners();
            updateStatus('Ready to edit', 'status-saved');

            // Auto-load first question
            if (data.chapters.length > 0 && data.chapters[0].questions && data.chapters[0].questions.length > 0) {
                setTimeout(() => {
                    loadQuestion(0, 0);
                }, 500);
            }
        }

        // Load Sidebar with Questions
        function loadSidebar() {
            const container = document.getElementById('questionsContainer');
            container.innerHTML = '';

            if (!data.chapters || data.chapters.length === 0) {
                container.innerHTML = '<div class="loading">📝 No chapters available</div>';
                return;
            }

            let totalQuestions = 0;

            data.chapters.forEach((chapter, chapterIndex) => {
                if (chapter.questions && chapter.questions.length > 0) {
                    chapter.questions.forEach((question, questionIndex) => {
                        const questionItem = document.createElement('div');
                        questionItem.className = 'question-item';
                        questionItem.innerHTML = `
                            <div class="question-chapter">${chapter.title || `Chapter ${chapterIndex + 1}`}</div>
                            <div class="question-title">${question.title || `Question ${questionIndex + 1}`}</div>
                        `;

                        questionItem.onclick = () => {
                            loadQuestion(chapterIndex, questionIndex);

                            // Update active state
                            document.querySelectorAll('.question-item').forEach(item => item.classList.remove('active'));
                            questionItem.classList.add('active');
                        };

                        container.appendChild(questionItem);
                        totalQuestions++;
                    });
                }
            });

            if (totalQuestions === 0) {
                container.innerHTML = '<div class="loading">📝 No questions found</div>';
            }
        }

        // Load Question Content
        function loadQuestion(chapterIndex, questionIndex) {
            if (isLoading) return;

            // Save current content before switching
            if (currentChapter >= 0 && currentQuestion >= 0) {
                saveCurrentContent();
            }

            isLoading = true;
            updateStatus('Loading...', 'status-saving');

            currentChapter = chapterIndex;
            currentQuestion = questionIndex;

            const question = data.chapters[chapterIndex].questions[questionIndex];

            // Load question title
            let questionTitle = question.title || '';

            // Prepare content
            let htmlBlocks = [];
            if (question.answers && question.answers[0] && question.answers[0].answer) {
                try {
                    const answerData = JSON.parse(question.answers[0].answer);
                    htmlBlocks = convertBlocksToHTML(answerData.blocks);
                } catch (error) {
                    console.error('Error parsing answer blocks:', error);
                    htmlBlocks = ['<p>Error loading content. Start writing here...</p>'];
                }
            } else {
                htmlBlocks = ['<p>Start writing your answer here...</p>'];
            }

            // Reset wrapper
            const wrapper = document.getElementById('documentWrapper');
            wrapper.innerHTML = '';

            // Start with first page
            let pageNum = 1;
            currentPageCount = 1;
            const createPage = (num) => {
                const page = document.createElement('div');
                page.className = 'document-page';
                page.id = `page-${num}`;
                page.innerHTML = `
            ${num === 1 ? `
            <div class="page-header">
                <input type="text" class="question-title-input" id="questionTitle" placeholder="Enter question title..." value="${questionTitle}">
            </div>` : ''}
            <div class="page-content" id="pageContent-${num}" contenteditable="true"></div>
            <div class="page-number">Page ${num}</div>
        `;
                wrapper.appendChild(page);
                setupPageEventListeners(num);
                return page;
            };

            let page = createPage(pageNum);
            let contentDiv = page.querySelector('.page-content');

            htmlBlocks.forEach(html => {
                const temp = document.createElement('div');
                temp.innerHTML = html;
                const node = temp.firstChild;

                contentDiv.appendChild(node);

                // Overflow check
                if (contentDiv.scrollHeight > MAX_PAGE_HEIGHT) {
                    contentDiv.removeChild(node);
                    pageNum++;
                    currentPageCount = pageNum;
                    page = createPage(pageNum);
                    contentDiv = page.querySelector('.page-content');
                    contentDiv.appendChild(node);
                }
            });

            // Small delay to trigger auto-pagination for long content
            setTimeout(() => {
                checkForOverflow();
                updateStatus('Loaded successfully', 'status-saved');
                isLoading = false;
            }, 100);
        }


        // Convert Blocks to HTML
        function convertBlocksToHTML(blocks) {
            return blocks.map(block => {
                switch (block.type) {
                    case 'header':
                        return `<h${block.data.level}>${block.data.text}</h${block.data.level}>`;
                    case 'paragraph':
                        return `<p>${block.data.text}</p>`;
                    case 'list':
                        const tag = block.data.style === 'ordered' ? 'ol' : 'ul';
                        return `<${tag}>${block.data.items.map(item => `<li>${item}</li>`).join('')}</${tag}>`;
                    default:
                        return `<p>${block.data.text}</p>`;
                }
            });
        }

        // Convert HTML to Blocks
        function convertHTMLToBlocks(htmlArray) {
            const blocks = [];
            let blockId = 1;

            htmlArray.forEach(html => {
                const temp = document.createElement('div');
                temp.innerHTML = html.trim();
                const el = temp.firstElementChild;

                if (!el) return;

                const tagName = el.tagName.toLowerCase();

                if (tagName.match(/^h[1-6]$/)) {
                    blocks.push({
                        id: `block_${blockId++}`,
                        type: 'header',
                        data: {
                            text: el.innerHTML,
                            level: parseInt(tagName.substring(1))
                        }
                    });
                } else if (tagName === 'p') {
                    blocks.push({
                        id: `block_${blockId++}`,
                        type: 'paragraph',
                        data: {
                            text: el.innerHTML
                        }
                    });
                } else if (tagName === 'ul' || tagName === 'ol') {
                    const items = Array.from(el.children).map(li => li.innerHTML);
                    blocks.push({
                        id: `block_${blockId++}`,
                        type: 'list',
                        data: {
                            style: tagName === 'ol' ? 'ordered' : 'unordered',
                            items
                        }
                    });
                } else {
                    // fallback
                    blocks.push({
                        id: `block_${blockId++}`,
                        type: 'paragraph',
                        data: {
                            text: el.outerHTML
                        }
                    });
                }
            });

            return blocks;
        }


        // CLEAN PAGE MANAGEMENT - NO ERRORS
        function checkForOverflow() {
    console.log(`🔍 Checking for overflow...`);
    for (let i = 1; i <= currentPageCount; i++) {
        const page = document.getElementById(`page-${i}`);
        const content = page?.querySelector('.page-content');
        if (!content) continue;

        while (content.scrollHeight > MAX_PAGE_HEIGHT && content.childElementCount > 1) {
            const nextPageNum = i + 1;
            if (!document.getElementById(`page-${nextPageNum}`)) {
                createNextPage(nextPageNum);
            }
            const nextContent = document.getElementById(`pageContent-${nextPageNum}`);
            const lastChild = content.lastElementChild;
            nextContent.insertBefore(lastChild, nextContent.firstChild);
        }

        // Reflow upward if needed (content was deleted)
        const prevPage = document.getElementById(`page-${i - 1}`);
        if (prevPage) {
            const prevContent = prevPage.querySelector('.page-content');
            const firstChild = content.firstElementChild;
            if (firstChild && content.scrollHeight < MAX_PAGE_HEIGHT - 40) {
                const prevLast = prevContent.lastElementChild;
                if (prevLast && prevContent.scrollHeight + prevLast.offsetHeight < MAX_PAGE_HEIGHT) {
                    content.insertBefore(prevLast, content.firstChild);
                }
            }
        }
    }
}




        // CREATE NEXT PAGE - SIMPLE AND CLEAN
        function createNextPage(pageNumber) {
            const wrapper = document.getElementById('documentWrapper');

            const newPage = document.createElement('div');
            newPage.className = 'document-page';
            newPage.id = `page-${pageNumber}`;

            newPage.innerHTML = `
                <div class="page-content" id="pageContent-${pageNumber}" contenteditable="true">
                </div>
                <div class="page-number">Page ${pageNumber}</div>
            `;

            wrapper.appendChild(newPage);
            currentPageCount = pageNumber;

            setupPageEventListeners(pageNumber);

            console.log(`✅ Created page ${pageNumber}. Total pages: ${currentPageCount}`);
        }

        // MOVE CONTENT TO NEXT PAGE - SIMPLE AND CLEAN
        function moveContentToNextPage(fromPageNum, toPageNum) {
            const fromPage = document.getElementById(`pageContent-${fromPageNum}`);
            const toPage = document.getElementById(`pageContent-${toPageNum}`);

            if (!fromPage || !toPage) return;

            console.log(`📋 Moving content from page ${fromPageNum} to page ${toPageNum}`);

            const elements = Array.from(fromPage.children);
            let totalHeight = 0;
            let splitIndex = elements.length;

            // Find where to split
            for (let i = 0; i < elements.length; i++) {
                const elementHeight = elements[i].offsetHeight + 20;
                if (totalHeight + elementHeight > MAX_PAGE_HEIGHT) {
                    splitIndex = i;
                    break;
                }
                totalHeight += elementHeight;
            }

            // Move elements
            if (splitIndex < elements.length) {
                const elementsToMove = elements.slice(splitIndex);

                elementsToMove.forEach(element => {
                    toPage.appendChild(element);
                });

                console.log(`✅ Moved ${elementsToMove.length} elements to page ${toPageNum}`);

                // Check if next page also overflows
                setTimeout(() => {
                    if (toPage.scrollHeight > MAX_PAGE_HEIGHT) {
                        checkForOverflow();
                    }
                }, 100);
            }
        }

        // GOOGLE DOCS ENTER KEY BEHAVIOR - CLEAN AND SIMPLE
        function setupPageEventListeners(pageNumber) {
    const pageContent = document.getElementById(`pageContent-${pageNumber}`);
    if (!pageContent) return;

    console.log(`🎧 Setting up listeners for page ${pageNumber}`);

    const debounceOverflowCheck = () => {
        clearTimeout(pageBreakTimer);
        pageBreakTimer = setTimeout(() => {
            checkForOverflow();
        }, 100);
    };

    const debounceSave = () => {
        clearTimeout(autoSaveTimer);
        autoSaveTimer = setTimeout(() => {
            saveCurrentContent();
        }, 2000);
    };

    // Unified input event (typing, delete, paste, etc.)
    pageContent.addEventListener('input', () => {
        updateStatus('Editing...', 'status-saving');
        debounceOverflowCheck();
        debounceSave();
    });

    // Also catch delete/backspace keydowns explicitly
    pageContent.addEventListener('keydown', (e) => {
        if (
            e.key === 'Backspace' || 
            e.key === 'Delete' || 
            e.key === 'Enter'
        ) {
            requestAnimationFrame(() => {
                debounceOverflowCheck();
            });
        }
    });
}



        // MOVE CONTENT AND CURSOR - FIXED GOOGLE DOCS STYLE
        // function moveContentAndCursor(fromPageNum, toPageNum) {
        //     const fromPage = document.getElementById(`pageContent-${fromPageNum}`);
        //     const toPage = document.getElementById(`pageContent-${toPageNum}`);

        //     if (!fromPage || !toPage) {
        //         console.error(`❌ Pages not found: from=${fromPageNum}, to=${toPageNum}`);
        //         return;
        //     }

        //     console.log(`🎯 Moving content and cursor: ${fromPageNum} → ${toPageNum}`);

        //     // Get all elements from the overflowing page
        //     const allElements = Array.from(fromPage.children);
        //     if (allElements.length === 0) {
        //         console.log(`📝 No elements to move, creating new paragraph on page ${toPageNum}`);

        //         // Create new paragraph on target page
        //         const newPara = document.createElement('p');
        //         newPara.innerHTML = '<br>';
        //         toPage.appendChild(newPara);

        //         // Focus and position cursor
        //         setTimeout(() => {
        //             toPage.focus();

        //             const range = document.createRange();
        //             range.setStart(newPara, 0);
        //             range.collapse(true);

        //             const selection = window.getSelection();
        //             selection.removeAllRanges();
        //             selection.addRange(range);

        //             console.log(`✅ Cursor moved to new paragraph on page ${toPageNum}`);
        //         }, 50);
        //         return;
        //     }

        //     // Calculate what should stay vs what should move
        //     let totalHeight = 0;
        //     let moveFromIndex = allElements.length; // Default: move nothing

        //     for (let i = 0; i < allElements.length; i++) {
        //         const elementHeight = allElements[i].offsetHeight + 20;

        //         if (totalHeight + elementHeight > MAX_PAGE_HEIGHT) {
        //             // If this is the first element that causes overflow, we need to move at least this element
        //             moveFromIndex = Math.max(1, i); // Move at least 1 element
        //             console.log(`📊 Split at element ${moveFromIndex}. Total elements: ${allElements.length}`);
        //             break;
        //         }
        //         totalHeight += elementHeight;
        //     }

        //     // Move the overflowing elements
        //     if (moveFromIndex < allElements.length) {
        //         const elementsToMove = allElements.slice(moveFromIndex);
        //         console.log(`📋 Moving ${elementsToMove.length} elements from page ${fromPageNum} to page ${toPageNum}`);

        //         // Move each element to the target page
        //         elementsToMove.forEach((element, index) => {
        //             console.log(`📄 Moving element ${index + 1}: ${element.tagName}`);
        //             toPage.appendChild(element);
        //         });

        //         // Focus the target page and position cursor at the first moved element
        //         setTimeout(() => {
        //             console.log(`🎯 Focusing page ${toPageNum}`);
        //             toPage.focus();

        //             if (elementsToMove.length > 0) {
        //                 const firstMovedElement = elementsToMove[0];

        //                 try {
        //                     const range = document.createRange();

        //                     // Position cursor at the beginning of the first moved element
        //                     if (firstMovedElement.firstChild && firstMovedElement.firstChild.nodeType === Node.TEXT_NODE) {
        //                         range.setStart(firstMovedElement.firstChild, 0);
        //                     } else if (firstMovedElement.firstChild) {
        //                         range.setStart(firstMovedElement.firstChild, 0);
        //                     } else {
        //                         range.setStart(firstMovedElement, 0);
        //                     }

        //                     range.collapse(true);

        //                     const selection = window.getSelection();
        //                     selection.removeAllRanges();
        //                     selection.addRange(range);

        //                     console.log(`✅ Cursor positioned at first moved element on page ${toPageNum}`);
        //                 } catch (error) {
        //                     console.error('Error positioning cursor:', error);

        //                     // Fallback: position at the beginning of the page
        //                     if (toPage.firstChild) {
        //                         const range = document.createRange();
        //                         range.setStart(toPage.firstChild, 0);
        //                         range.collapse(true);

        //                         const selection = window.getSelection();
        //                         selection.removeAllRanges();
        //                         selection.addRange(range);
        //                     }
        //                 }
        //             }
        //         }, 100);
        //     } else {
        //         // No elements to move, but still focus next page
        //         console.log(`🎯 No elements to move, just focusing page ${toPageNum}`);

        //         setTimeout(() => {
        //             toPage.focus();

        //             // If target page is empty, create a paragraph
        //             if (toPage.children.length === 0) {
        //                 const newPara = document.createElement('p');
        //                 newPara.innerHTML = '<br>';
        //                 toPage.appendChild(newPara);
        //             }

        //             // Position cursor at beginning of target page
        //             if (toPage.firstChild) {
        //                 const range = document.createRange();
        //                 range.setStart(toPage.firstChild, 0);
        //                 range.collapse(true);

        //                 const selection = window.getSelection();
        //                 selection.removeAllRanges();
        //                 selection.addRange(range);
        //             }

        //             console.log(`✅ Cursor positioned on page ${toPageNum}`);
        //         }, 100);
        //     }

        //     // Check if the target page also overflows after moving content
        //     setTimeout(() => {
        //         const targetHeight = toPage.scrollHeight;
        //         if (targetHeight > MAX_PAGE_HEIGHT) {
        //             console.log(`🔄 Page ${toPageNum} also overflowed (${targetHeight}px), checking again...`);
        //             checkForOverflow();
        //         }
        //     }, 200);
        // }
        function moveContentAndCursor(fromPageNum, toPageNum) {
            const fromPage = document.getElementById(`pageContent-${fromPageNum}`);
            const toPage = document.getElementById(`pageContent-${toPageNum}`);

            if (!fromPage || !toPage) {
                console.error(`❌ Pages not found: from=${fromPageNum}, to=${toPageNum}`);
                return;
            }

            const allElements = Array.from(fromPage.children);
            if (allElements.length === 0) {
                const newPara = document.createElement('p');
                newPara.innerHTML = '<br>';
                toPage.appendChild(newPara);
                setCursorAtStart(newPara);
                return;
            }

            // Calculate overflow using real bounding boxes
            let totalHeight = 0;
            let moveFromIndex = allElements.length;

            for (let i = 0; i < allElements.length; i++) {
                const rect = allElements[i].getBoundingClientRect();
                const elementHeight = rect.height || allElements[i].offsetHeight || 0;
                totalHeight += elementHeight + 10; // +10 for padding/margin buffer

                if (totalHeight > MAX_PAGE_HEIGHT) {
                    moveFromIndex = Math.max(1, i);
                    break;
                }
            }

            // Move if overflowed
            if (moveFromIndex < allElements.length) {
                const elementsToMove = allElements.slice(moveFromIndex);
                elementsToMove.forEach(el => toPage.appendChild(el));

                // Cursor positioning after DOM update
                setTimeout(() => {
                    if (elementsToMove.length > 0) {
                        setCursorAtStart(elementsToMove[0]);
                    } else {
                        ensureBlankPara(toPage);
                        setCursorAtStart(toPage.firstChild);
                    }

                    // Recursively check if destination page now also overflows
                    setTimeout(() => {
                        if (toPage.scrollHeight > MAX_PAGE_HEIGHT) {
                            console.log(`🔁 Page ${toPageNum} overflowed again, checking...`);
                            checkForOverflow();
                        }
                    }, 50);
                }, 50);
            } else {
                // Nothing to move but make sure target page has a paragraph and cursor
                ensureBlankPara(toPage);
                setCursorAtStart(toPage.firstChild);
            }
        }

        // ✅ Set cursor to beginning of element
        function setCursorAtStart(el) {
            try {
                const range = document.createRange();
                const selection = window.getSelection();

                if (el.firstChild?.nodeType === Node.TEXT_NODE) {
                    range.setStart(el.firstChild, 0);
                } else {
                    range.setStart(el, 0);
                }

                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);

                console.log(`✅ Cursor set`);
            } catch (e) {
                console.error('❌ Failed to set cursor:', e);
            }
        }

        // ✅ Ensure at least one blank paragraph exists
        function ensureBlankPara(page) {
            if (!page || page.children.length > 0) return;

            const newPara = document.createElement('p');
            newPara.innerHTML = '<br>';
            page.appendChild(newPara);
        }

        function getAllContent() {
            let blocks = [];
            let title = '';

            const titleInput = document.getElementById('questionTitle');
            if (titleInput) {
                title = titleInput.value;
            }

            for (let i = 1; i <= currentPageCount; i++) {
                const pageContent = document.getElementById(`pageContent-${i}`);
                if (pageContent) {
                    Array.from(pageContent.children).forEach(child => {
                        blocks.push(child.outerHTML);
                    });
                }
            }

            return {
                title,
                blocks
            };
        }


        // Auto-save
        function saveCurrentContent() {
            if (currentChapter < 0 || currentQuestion < 0) return;

            const allData = getAllContent();
            const title = allData.title;
            const content = allData.content;

            // Update question title
            data.chapters[currentChapter].questions[currentQuestion].title = title;

            // Convert HTML to blocks and save
            const blocks = convertHTMLToBlocks(content);

            if (!data.chapters[currentChapter].questions[currentQuestion].answers) {
                data.chapters[currentChapter].questions[currentQuestion].answers = [{
                    id: 1,
                    user_id: 1,
                    author_first_name: "User",
                    author_last_name: "",
                    answer: JSON.stringify({
                        time: Date.now(),
                        blocks: blocks
                    })
                }];
            } else {
                data.chapters[currentChapter].questions[currentQuestion].answers[0].answer = JSON.stringify({
                    time: Date.now(),
                    blocks: blocks
                });
            }

            updateStatus('Auto-saved locally', 'status-saved');

            // Trigger server save
            autoSaveCount++;
            if (autoSaveCount >= 5 || (Date.now() - lastServerSave) > 30000) {
                saveToServer();
            }
        }

        // Server save function
        function saveToServer() {
            console.log('🌐 Saving to server...');
            updateStatus('Syncing to server...', 'status-saving');

            const saveData = {
                action: 'save',
                data: data
            };

            const xhr = new XMLHttpRequest();
            xhr.open('POST', window.location.href, true);
            xhr.setRequestHeader('Content-Type', 'application/json');

            xhr.onload = function() {
                if (xhr.status >= 200 && xhr.status < 300) {
                    try {
                        // Check if response is HTML instead of JSON
                        if (xhr.responseText.trim().startsWith('<!DOCTYPE') || xhr.responseText.trim().startsWith('<html')) {
                            console.error('❌ Server returned HTML instead of JSON');
                            updateStatus('Server error: HTML response', 'status-error');
                            return;
                        }

                        const result = JSON.parse(xhr.responseText);
                        if (result.success) {
                            updateStatus('Synced to server', 'status-saved');
                            lastServerSave = Date.now();
                            autoSaveCount = 0;
                            console.log('✅ Server sync successful');
                        } else {
                            updateStatus('Sync failed: ' + (result.message || 'Unknown error'), 'status-error');
                        }
                    } catch (parseError) {
                        console.error('❌ JSON parse error:', parseError);
                        updateStatus('Server response error', 'status-error');
                    }
                } else {
                    updateStatus('Server error: ' + xhr.status, 'status-error');
                }
            };

            xhr.onerror = function() {
                console.error('❌ Network error');
                updateStatus('Network error', 'status-error');
            };

            try {
                xhr.send(JSON.stringify(saveData));
            } catch (error) {
                console.error('❌ Send error:', error);
                updateStatus('Send error', 'status-error');
            }
        }

        // Save All Changes
        function saveAllChanges() {
            if (currentChapter >= 0 && currentQuestion >= 0) {
                saveCurrentContent();
            }

            updateStatus('Saving all data...', 'status-saving');
            saveToServer();
        }

        // Export to PDF (Basic version)
        function exportToPDF() {
            updateStatus('Generating PDF...', 'status-saving');

            if (typeof window.jspdf === 'undefined' && typeof window.jsPDF === 'undefined') {
                alert('PDF library not loaded. Please refresh the page and try again.');
                updateStatus('PDF export failed', 'status-error');
                return;
            }

            try {
                let jsPDF;
                if (window.jspdf && window.jspdf.jsPDF) {
                    jsPDF = window.jspdf.jsPDF;
                } else if (window.jsPDF) {
                    jsPDF = window.jsPDF;
                } else {
                    throw new Error('jsPDF not found');
                }

                const pdf = new jsPDF('p', 'mm', 'a4');

                pdf.setFontSize(16);
                pdf.text('Book Export', 20, 20);

                pdf.setFontSize(12);
                pdf.text(`Generated on: ${new Date().toLocaleDateString()}`, 20, 35);

                const fileName = `Book_Export_${new Date().toISOString().split('T')[0]}.pdf`;
                pdf.save(fileName);

                updateStatus('PDF exported successfully', 'status-saved');

            } catch (error) {
                console.error('PDF Export Error:', error);
                alert('Error generating PDF: ' + error.message);
                updateStatus('PDF export failed', 'status-error');
            }
        }

        // Setup Event Listeners
        function setupEventListeners() {
            // Title input
            const titleInput = document.getElementById('questionTitle');
            if (titleInput) {
                titleInput.addEventListener('input', () => {
                    updateStatus('Editing...', 'status-saving');
                    clearTimeout(autoSaveTimer);
                    autoSaveTimer = setTimeout(() => {
                        saveCurrentContent();
                        loadSidebar();
                    }, 2000);
                });
            }

            // Search functionality
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    filterQuestions(e.target.value);
                });
            }

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case 'b':
                            e.preventDefault();
                            toggleFormat('bold');
                            break;
                        case 'i':
                            e.preventDefault();
                            toggleFormat('italic');
                            break;
                        case 'u':
                            e.preventDefault();
                            toggleFormat('underline');
                            break;
                        case 's':
                            e.preventDefault();
                            saveAllChanges();
                            break;
                        case 'p':
                            e.preventDefault();
                            printDocument();
                            break;
                    }
                }
            });

            document.addEventListener('selectionchange', updateToolbarState);

            // Setup first page listeners
            setupPageEventListeners(1);
        }

        // Formatting Functions
        function execCommand(command, value = null) {
            document.execCommand(command, false, value);
            updateToolbarState();
        }

        function toggleFormat(command) {
            execCommand(command);
        }

        function changeFontFamily(fontFamily) {
            execCommand('fontName', fontFamily);
        }

        function changeFontSize(size) {
            execCommand('fontSize', size);
        }

        function alignText(alignment) {
            const commands = {
                'left': 'justifyLeft',
                'center': 'justifyCenter',
                'right': 'justifyRight',
                'justify': 'justifyFull'
            };
            execCommand(commands[alignment]);
        }

        function insertList(listType) {
            const command = listType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
            execCommand(command);
        }

        function applyStyle(tag) {
            execCommand('formatBlock', tag);
        }

        function insertLink() {
            const url = prompt('Enter URL:');
            if (url) {
                execCommand('createLink', url);
            }
        }

        function insertImage() {
            const url = prompt('Enter image URL:');
            if (url) {
                execCommand('insertImage', url);
            }
        }

        function printDocument() {
            window.print();
        }

        function updateToolbarState() {
            const commands = ['bold', 'italic', 'underline'];
            commands.forEach(command => {
                const button = document.getElementById(command + 'Btn');
                if (button) {
                    button.classList.toggle('active', document.queryCommandState(command));
                }
            });
        }

        function filterQuestions(searchTerm) {
            const container = document.getElementById('questionsContainer');
            const items = container.querySelectorAll('.question-item');

            items.forEach(item => {
                const chapterText = item.querySelector('.question-chapter').textContent.toLowerCase();
                const questionText = item.querySelector('.question-title').textContent.toLowerCase();
                const matches = chapterText.includes(searchTerm.toLowerCase()) ||
                    questionText.includes(searchTerm.toLowerCase());

                item.style.display = matches ? 'block' : 'none';
            });
        }

        function updateStatus(message, className) {
            const statusText = document.getElementById('statusText');
            const statusIndicator = document.getElementById('statusIndicator');

            statusText.textContent = message;
            statusIndicator.className = 'status-indicator ' + className;
        }
    </script>
</body>

</html>